
\section{QFT use-case}
The Quantum Fourier Transform (QFT) is used as a building block in many quantum algorithms and for validation and benchmarking of circuit simulators. 
For these reasons it makes sense to use it as a use case for QuantEx.

\subsection{Introduction}
The QFT is the quantum analogue of the inverse Fourier transform. Given an input state $| \psi \rangle = \sum_{j=0}^{2^n-1} c_j | j \rangle $ defined over $n$ qubits, the 
QFT operator F acts on $\psi\rangle$ as

 $$F | \psi \rangle =  | \phi \rangle = \sum_{j=0}^{2^n-1} d_j | j \rangle$$ 
 
 where 
 
 $$d_j = \frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1} c_k e^{\frac{2\pi j}{2^n}jk}$$


\subsection{Quantum circuit description and construction}
For the purposes of this use case we start with the quantum circuit defined in \cite{coppersmith_approximate_2002} to calculate the QFT of a given input state. For this implementation
 the number of gates required is quadratic in the number of qubits. While not as efficient as other known circuits \cite{hales_improved_2000,kitaev_quantum_1995}, it is a very simple 
 circuit and should serve as a starting point.
 
 The circuit consists of Hadamard gates, controlled rotation gates and swap gates. For 3 qubits, the circuit looks like
 
\begin{equation*}
    \Qcircuit @C=1.0em @R=0.0em @!R {
                \lstick{ q_{0} : \ket{0} } & \gate{H} & \control \qw & \dstick{\frac{\pi}{4}}\qw & \control \qw & \dstick{\frac{\pi}{8}}\qw \barrier[0em]{2} & \qw & \qw & \qw & \qw \barrier[0em]{2} & \qw & \qw \barrier[0em]{2} & \qw & \qswap & \qw & \qw\\
                \lstick{ q_{1} : \ket{0} } & \qw & \ctrl{-1} & \qw & \qw & \qw & \qw & \gate{H} & \control \qw & \dstick{\frac{\pi}{4}}\qw & \qw & \qw & \qw & \qw & \qw & \qw\\
                \lstick{ q_{2} : \ket{0} } & \qw & \qw & \qw & \ctrl{-2} & \qw & \qw & \qw & \ctrl{-1} & \qw & \qw & \gate{H} & \qw & \qswap \qwx[-2] & \qw & \qw\\
         }
\end{equation*}

Larger circuits will have the same structure just with more iterations.
 
\subsection{Testing procedure}
The aim of using this circuit is twofold:

\begin{enumerate}
\item It provides validation of the correctness of the simulation results
\item It can be used to benchmark simulator performance and compare to other simulator platforms
\end{enumerate}

\subsubsection{Validation}
Simulating the QFT with the default input state which initialises all qubits to state $|0\rangle$ produces an equal superposition over 
all qubit configurations. This is not very effective for validating the correctness of the underlying simulation platform. To better test
the simulator we prepare the initial state in a less trivial state through the use of a simple parameterised ansatz circuit. 

%This simple 
%ansatz circuit we choose consists of a layer of single qubit unitary gates with randomly selected parameters followed by a layer of
%entangling gates between neighbouring qubits. While not capable of producing highly entangled states it should suffice for these purposes.

Validation then proceeds by measuring the amplitudes of a set of output configurations and comparing these to their expected amplitudes. For smaller circuits 
it will be possible to do this for every possibly configuration, but for larger circuits it will be necessary to use a sample of these.

\subsubsection{Benchmarking}
For benchmarking, we wish to compute the time taken for running the circuit with a range of circuit sizes and on different numbers of CPUs/GPUs and nodes. From 
these, the scaling behaviour can be characterised. It is important to be aware that if using compression techniques (to reduce the dimension of intermediate tensors) 
the runtime of the simulation will depend not only on the number of qubits and resources used, but also on the form and parameters of the ansatz circuit.

\subsubsection{Tasks}
Sketch of the tasks envisaged to implement this use cases are as follows:

\begin{enumerate}
\item Script to generate QASM for QFT circuit with a given number of qubits
\item Script to generate QASM for ansatz circuit of given size and parameters (or to allow simulator start from arbitrary input state)
\item Script to run simulator and calculate output amplitudes for a set of configurations
\item Script to compare amplitudes and estimate the accuracy of the simulation
\item Ability to accurately record run time
\item Collate timings and accuracies, plot results and document conclusions
\end{enumerate}
