\section{NCU use-case}
The application of two-qubit controlled unitary gates (operators) is essential to exploit the full extent of quantum devices. The CNOT (controlled $\sigma_x$) gate is a prime example, allowing the application of $\sigma_x$ to a target qubit if the controlling qubit is $\vert 1 \rangle$. A generalised variant of this gate type extends to $n$-controlling qubits, applying a unitary gate $U$ if they are all $\vert 1 \rangle$. This NCU ($n$-controlled unitary) gate can be an important tool in developing many algorithms. As such, we develop methods to generate circuits for realising such NCU gates.

\subsection{Introduction}
A fundamental element of computer science is branching, where the flow of control in a given program can take different paths based on some controlling logic. The \verb+if-else+ statements can be use to implement such logical control in classical devices. In quantum computing environments, the closest analogous operation are those of controlled unitary ($CU$) gates. The purpose of a CU gate is to apply a given unitary gate to a target qubit depending upon the values of another controlling qubit. The smallest variant of these such gates are the 2-qubit controlled gates, with the controlled-NOT (CNOT), and controlled Y-rotation (CR$_{y}$) being two such examples. 

It is known that all larger CU gates with $n$-control qubits (NCU) can be decomposed into fundamental 2-qubit controls~\cite{barenco_elementary_1995}. These gates form the back-bone of many other algorithms, with the diffusion gate in Grover's search algorithm~\cite{grover_1996} being a notable example. As such, having a scalable implementation allowing the use of these gates is important for evaluating many real-world examples and problems.

\subsection{Operations}
As an example, we can take the 2 qubit controlled-NOT ($\textrm{CNOT}_{c,t}$) gate, wherein the application of the NOT ($\sigma_x$) gate to a target qubit, $t$, is controlled by the values of another qubit, $c$, defined as:

\begin{align}
\textrm{CNOT}_{c,t}: \vert c \rangle \vert t \rangle 
\rightarrow 
(\vert 0 \rangle\langle 0 \vert \otimes \mathds{1} + \vert 1 \rangle\langle 1 \vert \otimes \sigma_x)\vert c \rangle \otimes \vert t.\rangle\end{align}

Applying this operation to all two qubit patterns yields the following truth table:
\begin{align}
\textrm{CNOT}_{0,1} \vert 00 \rangle & \rightarrow \vert 00 \rangle \\
\textrm{CNOT}_{0,1}\vert 01 \rangle & \rightarrow \vert 01 \rangle \\
\textrm{CNOT}_{0,1}\vert 10 \rangle & \rightarrow \vert 11 \rangle \\
\textrm{CNOT}_{0,1}\vert 11 \rangle & \rightarrow \vert 10 \rangle.
\end{align}


To extend the above CNOT gate to an $n$-controlled version, we require it to perform the following operation:
\begin{align}
\textrm{nCX}_{c_{1},\dots c_{n} ,t} : &\vert c_1 \rangle \dots\vert c_{n} \rangle \vert t \rangle \rightarrow \\ 
&\vert c_1 \rangle \dots \vert c_{n} \rangle \vert t \oplus (c_{1} \wedge \dots \wedge c_{n}) \rangle .
\end{align}


\subsection{Circuit description and construction}

As a circuit, the above CNOT gate is represented as

\begin{equation*}
\Qcircuit @C=1em @R=1em {
    & \ctrl{1} & \qw \\
    & \targ &  \qw
},
\end{equation*}
which is further expressed as an $n$-controlled variant by
\begin{equation*}
\Qcircuit @C=1em @R=1em {
    & \ctrl{1} & \qw \\
    & \ctrl{1} & \qw \\
    & \ctrl{1} & \qw \\
    & \vdots\qw & \qw \\
    & \ctrl{1} & \qw \\
    & \targ &  \qw
}
\end{equation*}
The above circuit can be arbitrarily extended to $n$ controlling qubits for an $n+1$ circuit.

To realise the $n$-controlled variant, we must first decompose the circuit into $2$-qubit gates. As a generalisation to any arbitrary number of control lines and unitary gate, the following decomposition can be applied iteratively to decompose any $n$-controlled unitary to 2-qubit gates~\cite{barenco_elementary_1995}:
\begin{align}\label{eqn:default_decomp}
\Qcircuit @C=.5em @R=0em @!R {
& \ctrl{1} & \qw & & & \qw & \ctrl{1} & \qw & \ctrl{1} & \ctrl{2} & \qw\\
& \ctrl{1} & \qw & & & \qw & \ctrl{1} & \qw & \ctrl{1} & \ctrl{2} & \qw\\
& \ctrl{1} & \qw & \push{\rule{.3em}{0em}=\rule{.3em}{0em}} & & \qw & \ctrl{1} & \qw & \ctrl{1} & \ctrl{2} & \qw\\
& \ctrl{1} & \qw & & & \qw & \ctrl{1} & \qw & \ctrl{1} & \ctrl{2} & \qw\\
& \ctrl{1} & \qw & & & \ctrl{1} & \targ & \ctrl{1} & \targ & \qw & \qw\\
& \gate{U} & \qw & & & \gate{\sqrt[\leftroot{-2}\uproot{2}]{U}} & \qw & \gate{\sqrt[\leftroot{-2}\uproot{2}]{U}^\dag} & \qw & \gate{\sqrt[\leftroot{-2}\uproot{2}]{U}} & \qw
},
\end{align}
This decomposition procedure generates a quadratic number of gate calls. For certain NCU gates, more efficient decompositions can be used. For a $3CU$ gate, the following decomposition reduces the call depth from 17 to 13 gates:
\newcommand{\rtU}[1][U]{\sqrt[4]{#1}}
\newcommand{\rtUd}[1][U]{\sqrt[4]{#1}^\dagger}
\begin{align}\label{eqn:3cu_decomp}
\Qcircuit @C=.5em @R=0em @!R {
& \ctrl{1} & \qw & & & \qw & \ctrl{3} & \ctrl{1} & \qw & \ctrl{1} & \qw & \qw & \qw & \ctrl{2} & \qw & \qw & \qw & \ctrl{2} & \qw & \qw \\
& \ctrl{1} & \qw & & & \qw & \qw & \targ & \ctrl{2} & \targ & \ctrl{2} & \ctrl{1} & \qw & \qw & \qw & \ctrl{1} & \qw & \qw & \qw & \qw \\
& \ctrl{1} & \qw & \push{\rule{.3em}{0em}=\rule{.3em}{0em}}
 & & \qw & \qw & \qw & \qw & \qw & \qw & \targ & \ctrl{1} & \targ & \ctrl{1} & \targ & \ctrl{1} & \targ & \ctrl{1} & \qw \\
& \gate{U} & \qw & & &\qw & \gate{\rtU{}} & \qw & \gate{\rtUd{}} & \qw & \gate{\rtU{}} & \qw & \gate{\rtUd{}} & \qw & \gate{\rtU{}} & \qw & \gate{\rtUd{}} & \qw & \gate{\rtU{}} & \qw
}.
\end{align}

Additionally, given the existence of auxiliary qubits $n_a$, we can further optimise and reduce the circuit depth for $n$-controlled NOT gates, given $n \geq 5$ and $n_a = n-2$. Further details of this decomposition are given in~\cite[Sec.~7.1]{barenco_elementary_1995}.

For completeness, we implement the above 3 decomposition strategies:
\begin{itemize}
\item Default quadratic decomposition as defined by circuit~\eqref{eqn:3cu_decomp} for $n \geq 2$ controls.
\item Improved 3CU decomposition.
\item Linear decomposition of $n\geq5$ controls using $a\geq n-2$ auxiliary qubits.
\end{itemize}
 
\subsection{Testing procedure}

\begin{enumerate}
\item It enables the implementation of generalised variants of additional quantum algorithms.
\item It provides functionality NCU unavailable in many other quantum software suites.
\item It allows for an easy means to generate deep quantum circuits, useful when verifying different tensor contraction and approximation strategies.
\item Examines the ability of the underlying suite to handle non-local 2-qubit gates at scale.
\end{enumerate}


\subsubsection{Validation}
Starting with a qubit register of $\vert 0 \rangle^{\otimes n}$, we can make use of an $n-1$ controlled unitary gate, where the control qubits are indexed as $c \in \{q_1,..,q_{n-1} \}$, and the target qubit as $ t = q_n$. We calculate the submatrix decomposition of the unitary matrix $U$ as $V=\sqrt{U}$ and $V^{\dagger}=\sqrt{U}^{\dagger}$. From here, we can recursively call the decomposition routine to further decompose gates with $n>1$ control lines. The base case can then rely on the available 2 qubit $CU$ routines to apply the appropriately decomposed gate matrix.

For validating this we can examine the states for the appropriate target to flip from $\vert 0\rangle$ to $\vert 1 \rangle$. By defining all potential starting states for a given qubit register and applying the NCU operation, we should see the case of $\vert 1 \rangle^{\otimes n} \vert 0 \rangle$ become $\vert 1 \rangle^{\otimes n} \vert 1 \rangle$. Larger NCU circuits will require the use of the optimised modules to ensure reasonable computational complexity.

\iffalse
\subsubsection{Benchmarking}
For benchmarking, we wish to compute the time taken for running the circuit with a range of circuit sizes and on different numbers of CPUs/GPUs and nodes. From 
these, the scaling behaviour can be characterised. It is important to be aware that if using compression techniques (to reduce the dimension of intermediate tensors) 
the runtime of the simulation will depend not only on the number of qubits and resources used, but also on the form and parameters of the ansatz circuit.

\subsubsection{Tasks}
Sketch of the tasks envisaged to implement this use cases are as follows:

\begin{enumerate}
\item Script to generate QASM for QFT circuit with a given number of qubits
\item Script to generate QASM for ansatz circuit of given size and parameters (or to allow simulator start from arbitrary input state)
\item Script to run simulator and calculate output amplitudes for a set of configurations
\item Script to compare amplitudes and estimate the accuracy of the simulation
\item Ability to accurately record run time
\item Collate timings and accuracies, plot results and document conclusions
\end{enumerate}
\fi