var documenterSearchIndex = {"docs":
[{"location":"algo/ncu/#NCU-module","page":"NCU","title":"NCU module","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"The NCU module enables the implementation of an n-qubit controlled unitary gate. In this instances, we have chosen to work primarily with nCX and nCZ gates, though others may also be used.","category":"page"},{"location":"algo/ncu/#Implementation","page":"NCU","title":"Implementation","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"The general principle follows the work of Barenco et al., Phys. Rev. A 52, 3457, (1995). All higher-order controlled quantum gates can be decomposed into 1 and 2 qubit gate calls, with varying degrees of optimisation. We implement the default quadratic gate decomposition strategy, alongside the 3CU optimised, and auxiliary register optimised variants.","category":"page"},{"location":"algo/ncu/#API","page":"NCU","title":"API","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"QuantExQASM.NCU.apply_ncu!(circuit::QuantExQASM.Circuit.Circ, q_ctrl::Vector, q_aux::Vector, q_tgt, U::QuantExQASM.GateOps.GateLabel)\nQuantExQASM.NCU.init_intermed_gates(circ::QuantExQASM.Circuit.Circ, num_ctrl::Union{Nothing, Int})\nQuantExQASM.NCU.register_gate(circ::QuantExQASM.Circuit.Circ, U::QuantExQASM.GateOps.GateLabel, gate::Matrix{<:Number})\nQuantExQASM.NCU.gen_intermed_gates(ctrl_depth::Int, U::QuantExQASM.GateOps.GateLabel)\nQuantExQASM.NCU.get_intermed_gate(U::QuantExQASM.GateOps.GateLabel)\nQuantExQASM.NCU.apply_cx!(c::QuantExQASM.Circuit.Circ, ctrl, tgt, reg)\nQuantExQASM.NCU.apply_cu!(c::QuantExQASM.Circuit.Circ, ctrl, tgt, reg, gl::QuantExQASM.GateOps.GateLabel)","category":"page"},{"location":"algo/ncu/#QuantExQASM.NCU.apply_ncu!-Tuple{QuantExQASM.Circuit.Circ,Array{T,1} where T,Array{T,1} where T,Any,QuantExQASM.GateOps.GateLabelP{Int64,Float64}}","page":"NCU","title":"QuantExQASM.NCU.apply_ncu!","text":"apply_ncu!(circuit::Circuit.Circ, q_ctrl::Vector, q_aux::Vector, q_tgt, U::GateOps.GateLabel)\n\nApply an n-qubit controlled gate operation on the given target qubit. Ensure the gate corresponding with symbol U is registered with g_map before use. Appends the GateCall operations to circuit\n\nArguments\n\ncircuit::Circuit.Circ\nctrls::Vector: \naux::Vector: \ntgt::Int:\nU::GateOps.GateLabel:\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QuantExQASM.NCU.init_intermed_gates-Tuple{QuantExQASM.Circuit.Circ,Union{Nothing, Int64}}","page":"NCU","title":"QuantExQASM.NCU.init_intermed_gates","text":"init_intermed_gates(circ::Circuit.Circ, num_ctrl::Union{Nothing, Int})\n\nGenerates the required intermediate gates for implementing the NCU using the given Circuit gate-set. Calling this routine is essential before running the NCU.apply_ncu! function.\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QuantExQASM.NCU.register_gate-Tuple{QuantExQASM.Circuit.Circ,QuantExQASM.GateOps.GateLabelP{Int64,Float64},Array{#s4,2} where #s4<:Number}","page":"NCU","title":"QuantExQASM.NCU.register_gate","text":"register_gate(circ::Circuit.Circ, U::GateOps.GateLabel, gate::Matrix{<:Number})\n\nAdds the user-defined gate to the cache with the pairing U=>gate\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QuantExQASM.NCU.gen_intermed_gates-Tuple{Int64,QuantExQASM.GateOps.GateLabelP{Int64,Float64}}","page":"NCU","title":"QuantExQASM.NCU.gen_intermed_gates","text":"gen_intermed_gates(ctrl_depth::Int, U::GateOps.GateLabel)\n\nGenerates all intermediate n-th root gates upto the given control depth.\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QuantExQASM.NCU.get_intermed_gate-Tuple{QuantExQASM.GateOps.GateLabelP{Int64,Float64}}","page":"NCU","title":"QuantExQASM.NCU.get_intermed_gate","text":"get_intermed_gate(U::GateOps.GateLabel)\n\nGenerate sqrt U and adjoint sqrt U, given a previously cached gate U.\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QuantExQASM.NCU.apply_cx!-Tuple{QuantExQASM.Circuit.Circ,Any,Any,Any}","page":"NCU","title":"QuantExQASM.NCU.apply_cx!","text":"apply_cx!(c::Circuit.Circ, ctrl, tgt, reg)\n\nModule-specific CX gate. Defaults to using the implementation from GateOps. Override for custom functionality.\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#QuantExQASM.NCU.apply_cu!-Tuple{QuantExQASM.Circuit.Circ,Any,Any,Any,QuantExQASM.GateOps.GateLabelP{Int64,Float64}}","page":"NCU","title":"QuantExQASM.NCU.apply_cu!","text":"apply_cu!(c::Circuit.Circ, ctrl, tgt, reg, gl::GateOps.GateLabel)\n\nModule-specific CU gate. Defaults to using the implementation from GateOps. Override for custom functionality.\n\n\n\n\n\n","category":"method"},{"location":"algo/ncu/#Example","page":"NCU","title":"Example","text":"","category":"section"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"To use the NCU module, we provide example code below to apply an n-controlled Pauli Z gate using either the optimised or unoptimised (quadratic) decomposition routines.","category":"page"},{"location":"algo/ncu/","page":"NCU","title":"NCU","text":"using QuantExQASM\n\n# Set 5-qubit limit on circuit\nnum_qubits = 5\n\n# Do not use optimised routines\nuse_aux_qubits = false\n\n# Create Pauli-Z gate-label for application\ngl = QuantExQASM.GateOps.GateLabel(:z)\n\n# Create empty circuit with qiven qubit count\ncct = QuantExQASM.Circuit.Circ(num_qubits)\n\n# Initialise default intermediate gates (X,Y,Z,H) for use in NCU\nQuantExQASM.NCU.init_intermed_gates(cct, num_qubits-1)\n\nU = QuantExQASM.Circuit.gate_cache[gl]\n\nif use_aux_qubits == true && (num_qubits/2+1 >= 4)\n    ctrl = collect(0:Int( floor((num_qubits-1)//2) ))\n    aux = collect(1 + Int( floor((num_qubits-1)//2)):num_qubits-2)\n    tgt = num_qubits-1\nelse\n    ctrl = collect(0:num_qubits-2)\n    aux = Int[]\n    tgt = num_qubits-1\nend\n\nfor i in ctrl\n    QuantExQASM.Circuit.add_gatecall!(cct, QuantExQASM.GateOps.pauli_x(i) )\nend\n\nQuantExQASM.NCU.apply_ncu!(cct, ctrl, aux, tgt, gl);\n\n# Number of generation gate-call operations\nprintln(cct.circ_ops.len)","category":"page"},{"location":"gates_circuits/GateOps/#Gate-Operations","page":"Gates","title":"Gate Operations","text":"","category":"section"},{"location":"gates_circuits/GateOps/#Gate-type-system-hierarchy","page":"Gates","title":"Gate type-system hierarchy","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"Abstraction of types for representing gates.","category":"page"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"QuantExQASM.GateOps.AGate\nQuantExQASM.GateOps.AGateLabel\nQuantExQASM.GateOps.AGateCall","category":"page"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.AGate","page":"Gates","title":"QuantExQASM.GateOps.AGate","text":"Abstract Gate type\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.AGateLabel","page":"Gates","title":"QuantExQASM.GateOps.AGateLabel","text":"Abstract Gate Label, for unique gates\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.AGateCall","page":"Gates","title":"QuantExQASM.GateOps.AGateCall","text":"Abstract Gate Call, for tracking Gate labels applied to specific qubits\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#GateLabel-and-GateCall","page":"Gates","title":"GateLabel and GateCall","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"Specific gate instance in a circuit, applied to a given (set of) qubit(s).","category":"page"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"QuantExQASM.GateOps.GateLabelP{IType<:Integer, NType<:Number}\nQuantExQASM.GateOps.GateCall1P{IType<:Integer, NType<:Number}\nQuantExQASM.GateOps.GateCall2P{IType<:Integer, NType<:Number}\nQuantExQASM.GateOps.GateCallNP{IType<:Integer, NType<:Number}\nQuantExQASM.GateOps.Gate","category":"page"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.GateLabelP","page":"Gates","title":"QuantExQASM.GateOps.GateLabelP","text":"Parametric Gate label. Tracks the gate symbol (:x,:y,:z, etc), and arbitrary parameters\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.GateCall1P","page":"Gates","title":"QuantExQASM.GateOps.GateCall1P","text":"Parametric single qubit Gate call. Has a GateLabelP, target qubit index and register label\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.GateCall2P","page":"Gates","title":"QuantExQASM.GateOps.GateCall2P","text":"Parametric two qubit Gate call.  Has a GateLabelP, control and target qubit indices, register label, and base gate (assumes controlled U).\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.GateCallNP","page":"Gates","title":"QuantExQASM.GateOps.GateCallNP","text":"Parametric n-qubit Gate call.  Has a GateLabelP, control vector indices, target qubit index, register label, and base gate.\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.Gate","page":"Gates","title":"QuantExQASM.GateOps.Gate","text":"Wrap of Matrix to fit type system hierarchy\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/GateOps/#Single-Qubit-Gates:-default","page":"Gates","title":"Single Qubit Gates: default","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"QuantExQASM.GateOps.pauli_x(q_target::Int, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.pauli_y(q_target::Int, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.pauli_z(q_target::Int, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.hadamard(q_target::Int, register::Union{String, Nothing}=nothing)","category":"page"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.pauli_x","page":"Gates","title":"QuantExQASM.GateOps.pauli_x","text":"pauli_x(q_target::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit Pauli-x GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.pauli_x(0, \"q\")\nQuantExQASM.GateOps.GateCall1P{Int64,Float64}(QuantExQASM.GateOps.GateLabelP{Int64,Float64}(:x, nothing), 0, \"q\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.pauli_y","page":"Gates","title":"QuantExQASM.GateOps.pauli_y","text":"pauli_y(q_target::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit Pauli-y GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.pauli_y(0, \"q\")\nQuantExQASM.GateOps.GateCall1P{Int64,Float64}(QuantExQASM.GateOps.GateLabelP{Int64,Float64}(:y, nothing), 0, \"q\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.pauli_z","page":"Gates","title":"QuantExQASM.GateOps.pauli_z","text":"pauli_z(q_target::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit Pauli-z GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.pauli_z(0, \"q\")\nQuantExQASM.GateOps.GateCall1P{Int64,Float64}(QuantExQASM.GateOps.GateLabelP{Int64,Float64}(:z, nothing), 0, \"q\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.hadamard","page":"Gates","title":"QuantExQASM.GateOps.hadamard","text":"hadamard(q_target::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit Hadamard GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.hadamard(0, \"q\")\nGateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:h, nothing), 0, \"q\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#Single-Qubit-Gates:-rotation-and-arbitrary","page":"Gates","title":"Single Qubit Gates: rotation and arbitrary","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"QuantExQASM.GateOps.u(label::QuantExQASM.GateOps.GateLabel, q_target::Int, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.r_x(q_target::Int, theta::Number, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.r_y(q_target::Int, theta::Number, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.r_z(q_target::Int, theta::Number, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.r_phase(q_target::Int, theta::Number, register::Union{String, Nothing}=nothing)","category":"page"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.u","page":"Gates","title":"QuantExQASM.GateOps.u","text":"u(label::GateLabel, q_target::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit arbitrary unitary GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.u(GateOps.GateLabel(:mygate), 1, \"qr\")\nGateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:mygate, nothing), 1, \"qr\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.r_x","page":"Gates","title":"QuantExQASM.GateOps.r_x","text":"r_x(q_target::Int, theta::Real, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit R_x(θ) GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.r_x(3,pi/2)\nGateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(Symbol(\"r_x_angle=1.5707963267948966\"), Dict{String,Union{Bool, Float64, Int64}}(\"angle\"=>1.5708)), 3, nothing)\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.r_y","page":"Gates","title":"QuantExQASM.GateOps.r_y","text":"r_y(q_target::Int, theta::Real, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit R_y(θ) GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.r_y(3,pi/2)\nGateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(Symbol(\"r_y_angle=1.5707963267948966\"), Dict{String,Union{Bool, Float64, Int64}}(\"angle\"=>1.5708)), 3, nothing)\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.r_z","page":"Gates","title":"QuantExQASM.GateOps.r_z","text":"r_z(q_target::Int, theta::Real, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit R_z(θ) GateCall (GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.r_z(3,pi/2)\nGateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(Symbol(\"r_z_angle=1.5707963267948966\"), Dict{String,Union{Bool, Float64, Int64}}(\"angle\"=>1.5708)), 3, nothing)\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.r_phase","page":"Gates","title":"QuantExQASM.GateOps.r_phase","text":"r_phase(q_target::Int, theta::Real, register::Union{String, Nothing}=nothing)\n\nGenerate a single qubit phase shift GateCall ( diag(1, exp(1im*theta)) , GateCall1P) applied to the target qubit (on given register, if provided)\n\nExamples\n\njulia> GateOps.r_phase(3,pi/2)\nGateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(Symbol(\"r_phase_angle=1.5707963267948966\"), Dict{String,Union{Bool, Float64, Int64}}(\"angle\"=>1.5708)), 3, nothing)\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#Two-Qubit-Gates:-default","page":"Gates","title":"Two Qubit Gates: default","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"QuantExQASM.GateOps.c_pauli_x(q_target::Int, q_ctrl::Int, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.c_pauli_y(q_target::Int, q_ctrl::Int, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.c_pauli_z(q_target::Int, q_ctrl::Int, register::Union{String, Nothing}=nothing)","category":"page"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.c_pauli_x","page":"Gates","title":"QuantExQASM.GateOps.c_pauli_x","text":"c_pauli_x(q_target::Int, q_ctrl::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a controlled Pauli-x (two qubit) GateCall (GateCall2P), controlled on the index q_ctrl applied to the target q_target (on given register, if provided).\n\nExamples\n\njulia> GateOps.c_pauli_x(0, 1, \"qreg\")\nGateOps.GateCall2P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:c_x, nothing), 0, 1, GateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:x, nothing), 0, \"qreg\"), \"qreg\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.c_pauli_y","page":"Gates","title":"QuantExQASM.GateOps.c_pauli_y","text":"c_pauli_y(q_target::Int, q_ctrl::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a controlled Pauli-y (two qubit) GateCall (GateCall2P), controlled on the index q_ctrl applied to the target q_target (on given register, if provided).\n\nExamples\n\njulia> GateOps.c_pauli_y(0, 1, \"qreg\")\nGateOps.GateCall2P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:c_y, nothing), 0, 1, GateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:y, nothing), 0, \"qreg\"), \"qreg\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.c_pauli_z","page":"Gates","title":"QuantExQASM.GateOps.c_pauli_z","text":"c_pauli_z(q_target::Int, q_ctrl::Int, register::Union{String, Nothing}=nothing)\n\nGenerate a controlled Pauli-x (two qubit) GateCall (GateCall2P), controlled on the index q_ctrl applied to the target q_target (on given register, if provided).\n\nExamples\n\njulia> GateOps.c_pauli_z(0, 1, \"qreg\")\nGateOps.GateCall2P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:c_z, nothing), 0, 1, GateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:z, nothing), 0, \"qreg\"), \"qreg\")\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/GateOps/#Two-Qubit-Gates:-rotation-and-arbitrary","page":"Gates","title":"Two Qubit Gates: rotation and arbitrary","text":"","category":"section"},{"location":"gates_circuits/GateOps/","page":"Gates","title":"Gates","text":"QuantExQASM.GateOps.c_u(label::QuantExQASM.GateOps.GateLabel, q_target::Int, q_ctrl::Int, gc::QuantExQASM.GateOps.GateCall1, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.c_r_x(q_target::Int, q_ctrl::Int, theta::Real, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.c_r_y(q_target::Int, q_ctrl::Int, theta::Real, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.c_r_z(q_target::Int, q_ctrl::Int, theta::Real, register::Union{String, Nothing}=nothing)\nQuantExQASM.GateOps.c_r_phase(q_target::Int, q_ctrl::Int, theta::Real, register::Union{String, Nothing}=nothing)","category":"page"},{"location":"gates_circuits/GateOps/#QuantExQASM.GateOps.c_u","page":"Gates","title":"QuantExQASM.GateOps.c_u","text":"c_u(label::GateLabel, q_target::Int, q_ctrl::Int, gc::GateCall1, register::Union{String, Nothing}=nothing)\n\nGenerate a controlled unitary (two qubit) GateCall (GateCall2P), controlled on the index q_ctrl applied to the target q_target (on given register, if provided).\n\nExamples\n\njulia> GateOps.c_u(GateOps.GateLabel(:myCU), 0, 1, GateOps.pauli_x(0), \"q\")\nGateOps.GateCall2P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:myCU, nothing), 0, 1, GateOps.GateCall1P{Int64,Float64}(GateOps.GateLabelP{Int64,Float64}(:x, nothing), 0, nothing), \"q\")\n\n\n\n\n\n","category":"function"},{"location":"algo/grover/#Grover-Search","page":"Grover","title":"Grover Search","text":"","category":"section"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"The Grover.jl module implements a Grover's search use-case. Assisted by Oracle.jl and Diffusion.jl, the appropriate chosen test state is marked by applying an nCZ gate, and appropriately amplified through the required number of iterations rapprox pisqrt2^n+14.","category":"page"},{"location":"algo/grover/#API","page":"Grover","title":"API","text":"","category":"section"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"QuantExQASM.Grover.run_grover!(cct::QuantExQASM.Circuit.Circ, qubit_indices::Vector, state::Integer)\nQuantExQASM.Grover.mark_state!(cct::QuantExQASM.Circuit.Circ, state::Integer, qubit_indices::Vector)\nQuantExQASM.Grover.apply_grover_iteration!(cct::QuantExQASM.Circuit.Circ, qubit_indices::Vector)\nQuantExQASM.Grover.state_init!(cct::QuantExQASM.Circuit.Circ, qubit_indices::Vector)\nQuantExQASM.Grover.calc_iterations(num_states::Integer)\nQuantExQASM.Grover.apply_x!(cct::QuantExQASM.Circuit.Circ, tgt, reg::Union{String, Nothing}=nothing) \nQuantExQASM.Grover.apply_h!(cct::QuantExQASM.Circuit.Circ, tgt, reg::Union{String, Nothing}=nothing)","category":"page"},{"location":"algo/grover/#QuantExQASM.Grover.run_grover!-Tuple{QuantExQASM.Circuit.Circ,Array{T,1} where T,Integer}","page":"Grover","title":"QuantExQASM.Grover.run_grover!","text":"run_grover!(cct::Circuit.Circ, qubit_indices::Vector, state::Integer)\n\nGenerates a Grover search circuit sample, marking the state defined by state and performing iterations to amplify the desired result upon measurement.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QuantExQASM.Grover.mark_state!-Tuple{QuantExQASM.Circuit.Circ,Integer,Array{T,1} where T}","page":"Grover","title":"QuantExQASM.Grover.mark_state!","text":"mark_state!(cct::Circuit.Circ, state::Integer, qubit_indices::Vector)\n\nApplies the state marking procedure of the Grover iteration.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QuantExQASM.Grover.apply_grover_iteration!-Tuple{QuantExQASM.Circuit.Circ,Array{T,1} where T}","page":"Grover","title":"QuantExQASM.Grover.apply_grover_iteration!","text":"apply_grover_iteration!(cct::Circuit.Circ, qubit_indices::Vector)\n\nApplies a single Grover iteration. To be used following mark_state!\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QuantExQASM.Grover.state_init!-Tuple{QuantExQASM.Circuit.Circ,Array{T,1} where T}","page":"Grover","title":"QuantExQASM.Grover.state_init!","text":"state_init!(cct::Circuit.Circ, qubit_indices::Vector)\n\nInitialises the state to the required target; defaults to H^otimes nvert psi rangle . Override for custom initialisation.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QuantExQASM.Grover.calc_iterations-Tuple{Integer}","page":"Grover","title":"QuantExQASM.Grover.calc_iterations","text":"calc_iterations(num_states::Integer)\n\nCalculate the required number of iterations to maximise the state's amplitude.\n\n\n\n\n\n","category":"method"},{"location":"algo/grover/#QuantExQASM.Grover.apply_x!","page":"Grover","title":"QuantExQASM.Grover.apply_x!","text":"apply_x!(cct::Circuit.Circ, tgt, reg::Union{String, Nothing}=nothing)\n\nInternally used PauliX implementation. Uses GateOps definition. Override for custom use.\n\n\n\n\n\n","category":"function"},{"location":"algo/grover/#QuantExQASM.Grover.apply_h!","page":"Grover","title":"QuantExQASM.Grover.apply_h!","text":"apply_h!(cct::Circuit.Circ, tgt, reg::Union{String, Nothing}=nothing)\n\nInternally used Hadamard implementation. Uses GateOps definition. Override for custom use.\n\n\n\n\n\n","category":"function"},{"location":"algo/grover/#Example","page":"Grover","title":"Example","text":"","category":"section"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"To use the Grover module, we provide example code below to search for a state in a 5-qubit quantum register marked by bit-pattern 11 (0b01011).","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"using QuantExQASM\n\n# Set 5-qubit limit on circuit\nnum_qubits = 5\n\n# Set bit-pattern to 11 (0b01011)\nbit_pattern = 11\n\n# Do not use optimised routines\nuse_aux_qubits = false\n\n# Create empty circuit with qiven qubit count\ncct = QuantExQASM.Circuit.Circ(num_qubits)\n\n# Initialise intermediate gates for use in NCU\nQuantExQASM.NCU.init_intermed_gates(cct, num_qubits-1)\n\n# Run Grover algorithm for given oracle bit-pattern\nQuantExQASM.Grover.run_grover!(cct, collect(0:num_qubits-1), bit_pattern)","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"From here we can examine how many operations were generated as","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"println(cct.circ_ops.len)","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"We can also generate the OpenQASM equivalent circuit as","category":"page"},{"location":"algo/grover/","page":"Grover","title":"Grover","text":"# Convert circuit to QASM populated buffer\ncct_s = QuantExQASM.Circuit.to_qasm(cct, true)\n\n# Print first 8 lines of QASM file\nfor i in split( String(cct_s), \"\\n\")[1:8]\n    println(i)\nend","category":"page"},{"location":"gates_circuits/circuits/#Circuits","page":"Circuits","title":"Circuits","text":"","category":"section"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"To compose a quantum algorithm, we need a structured manner for representing the gate calls, as defined in GateOps.md. ","category":"page"},{"location":"gates_circuits/circuits/#Circuit.jl","page":"Circuits","title":"Circuit.jl","text":"","category":"section"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"The Circuit.jl module allows us to structure the gate-calls into a quantum circuit representation. Circuits are appendable, pushable, and are represented under the hood as a doubly linked-list (CList from module CircuitList.jl), to allow ease of further optimisation and manipulation, if required.","category":"page"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"The Circuit module also maintains a cached mapping from GateLabels to numerical matrices, wherein new gates created are stored for later use by other circuits. This memoization improves the performance of constructing circuits involving calculating sub-matrices (see the algorithms modules for examples).","category":"page"},{"location":"gates_circuits/circuits/","page":"Circuits","title":"Circuits","text":"QuantExQASM.Circuit.Circ\nQuantExQASM.Circuit.Circ()\nQuantExQASM.Circuit.Circ(num_qubits)\n\nQuantExQASM.Circuit.add_to_cache(label::QuantExQASM.GateOps.GateLabel, mat::Matrix{<:Number})\nQuantExQASM.Circuit.add_gatecall!(circ::QuantExQASM.Circuit.Circ, gc::QuantExQASM.GateOps.GateCall1)\nQuantExQASM.Circuit.add_gatecall!(circ::QuantExQASM.Circuit.Circ, gc::QuantExQASM.GateOps.GateCall2)\n\nQuantExQASM.Circuit.to_string(circ::QuantExQASM.Circuit.Circ)\nQuantExQASM.Circuit.gatelabel_to_qasm(gl::QuantExQASM.GateOps.GateLabel)\nQuantExQASM.Circuit.gatecall_to_qasm(gc::QuantExQASM.GateOps.GateCall1)\nQuantExQASM.Circuit.gatecall_to_qasm(gc::QuantExQASM.GateOps.GateCall2)\n\nQuantExQASM.Circuit.add_header(num_qubits::Int, reg::String=\"q\", creg::String=\"c\")\nQuantExQASM.Circuit.to_qasm(circ::QuantExQASM.Circuit.Circ, header::Bool=true, filename::Union{String, Nothing}=nothing)","category":"page"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.Circ","page":"Circuits","title":"QuantExQASM.Circuit.Circ","text":"Circ\n\nStructure for ordered quantum circuit gate operations.  Maintains MLL of gate-calls and a set of the gates used.\n\n\n\n\n\n","category":"type"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.Circ-Tuple{}","page":"Circuits","title":"QuantExQASM.Circuit.Circ","text":"Circ()\n\nDefault constructor for empty circuit. Registers Pauli and Hadamard gates during initialisation.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.Circ-Tuple{Any}","page":"Circuits","title":"QuantExQASM.Circuit.Circ","text":"Circ(num_qubits)\n\nCirc constructor for given number of qubits circuit. Registers Pauli and Hadamard gates during initialisation.\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.add_to_cache-Tuple{QuantExQASM.GateOps.GateLabelP{Int64,Float64},Array{#s4,2} where #s4<:Number}","page":"Circuits","title":"QuantExQASM.Circuit.add_to_cache","text":"add_to_cache(label::GateOps.GateLabel, mat::Matrix{<:Number})\n\nAdds a mapping between label=>mat for fast retrieval of gates in circuit generation.\n\nExamples\n\njulia> Circuit.add_to_cache(GateOps.GateLabel(:x), [0 1;1 0].+0im)\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.add_gatecall!-Tuple{QuantExQASM.Circuit.Circ,QuantExQASM.GateOps.GateCall1P{Int64,Float64}}","page":"Circuits","title":"QuantExQASM.Circuit.add_gatecall!","text":"add_gatecall!(circ::Circ, gc::GateOps.AGateCall)\n\nAdds the given gate call gc to the circuit at the end position.\n\nExamples\n\njulia> Circuit.add_gatecall!(circ, GateOps.paul_x(4)) #Apply Paulix to qubit index 4\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.add_gatecall!-Tuple{QuantExQASM.Circuit.Circ,QuantExQASM.GateOps.GateCall2P{Int64,Float64}}","page":"Circuits","title":"QuantExQASM.Circuit.add_gatecall!","text":"add_gatecall!(circ::Circ, gc::GateOps.AGateCall)\n\nAdds the given gate call gc to the circuit at the end position.\n\nExamples\n\njulia> Circuit.add_gatecall!(circ, GateOps.c_paul_x(3,4)) #Apply C_Paulix to qubit index 3, controlled on 4\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.to_string-Tuple{QuantExQASM.Circuit.Circ}","page":"Circuits","title":"QuantExQASM.Circuit.to_string","text":"to_string(circ::Circ)\n\nConvert the circuit to a string intermediate representation\n\nExamples\n\njulia> Circuit.add_gatecall!(circ, GateOps.paul_x(4)) #Apply Paulix to qubit index 4\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.gatelabel_to_qasm-Tuple{QuantExQASM.GateOps.GateLabelP{Int64,Float64}}","page":"Circuits","title":"QuantExQASM.Circuit.gatelabel_to_qasm","text":"gatelabel_to_qasm(gl::GateOps.GateLabel)\n\nDefines an OpenQASM gate from the given GateLabel and matched matrix\n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.gatecall_to_qasm-Tuple{QuantExQASM.GateOps.GateCall1P{Int64,Float64}}","page":"Circuits","title":"QuantExQASM.Circuit.gatecall_to_qasm","text":"gatecall_to_qasm(gc::GateOps.GateCall1)\n\nConvert a single-qubit gate call (GateCall1) to OpenQASM \n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.gatecall_to_qasm-Tuple{QuantExQASM.GateOps.GateCall2P{Int64,Float64}}","page":"Circuits","title":"QuantExQASM.Circuit.gatecall_to_qasm","text":"gatecall_to_qasm(gc::GateOps.GateCall2)\n\nConvert a two-qubit gate call (GateCall2) to OpenQASM \n\n\n\n\n\n","category":"method"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.add_header","page":"Circuits","title":"QuantExQASM.Circuit.add_header","text":"add_header(num_qubits::Int, reg::String=\"q\", creg::String=\"c\")\n\nReturns the given OpenQASM header for number of quantum and classical bits.\n\n\n\n\n\n","category":"function"},{"location":"gates_circuits/circuits/#QuantExQASM.Circuit.to_qasm","page":"Circuits","title":"QuantExQASM.Circuit.to_qasm","text":"to_qasm(circ::Circ, header::Bool=true, filename::Union{String, Nothing}=nothing)\n\nConvert a given circuit to OpenQASM.\n\n\n\n\n\n","category":"function"},{"location":"#QuantExQASM.jl-Documentation","page":"Home","title":"QuantExQASM.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantExQASM.jl is a generator suite for quantum algorithms. Using a high-level approach to quantum circuit design, we create quantum circuits taking note of all intermediate gate-calls between qubits, performing operation caching and optimisation where possible. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we support a limited set of quantum algoritms (see the Algorithms dropdown for details), where the resulting methods can be used to generate OpenQASM output, or integrated with the PicoQuant.jl package to create and run a tensor network simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"An example of using this package is given in the global repository protypes/bin directory as the script use_cases.jl.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#QuantExQASM.jl-Tutorial","page":"Tutorial","title":"QuantExQASM.jl Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Author = \"Lee J. O'Riordan\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"QuantExQASM is a ...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using QuantExQASM\n","category":"page"},{"location":"tutorial/#Gates-and-Circuits","page":"Tutorial","title":"Gates and Circuits","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When used with a DataFrame, the plot function in Gadfly is of the form:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x = GateOps.GateLabel(:x)\n","category":"page"}]
}
